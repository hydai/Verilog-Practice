// Recursive Fibonacci function
//   Input is stored at M[1024]
//   Result is put at M[1025]
//
// Note: This version is only for your reference.  It may not be
// verified completely.  Please report any bug you find out.

@0	
0100010_01000_00000__000010000000000	// addi $t0, $r0, 1024  
0100010_11101_00000__000011111111111	// addi $sp, $r0, 2047  
0010000_00100_01000__000000000000000	// lw  $a0, M[$t0]      
0110000_11111_00000__000000000000100	// jal $ra, 4           
0100010_01000_00000__000010000000001	// addi $t0, $r0, 1025  
0100000_00000_01000_00010_0000000000	// sw M[$t0], $v0       
0100010_01000_00000__000000000101000	// addi $t0, $r0, 40    
1110000_00000_01000__000000000000000	// jr $t0               

//fib:
 
0100010_00001_00000__000000000000001	// addi $at, $r0, 2  	# if i < 2 (i.e i == 1)
1100101_01000_00100_00001_0000000000	// slt $t0, $a0, $at	
1100000_00000_01000__000000000000010 	// beq $t0, $r0, +2	    # if i >= 2 go to cont
0100010_00010_00000__000000000000001	//addi $v0, $r0, 1	    # else make the return value 1
1110000_00000_11111__000000000000000	//jr $ra                
 
 
//cont:
 
// OPERATION 1: MAKE SPACE IN STACK
 
0100010_11101_11101__111111111111100	//addi $sp, $sp, -4		# make space for 3 elements in the stack
0100000_00000_11101_11111_0000000000    //sw $ra, M[$sp]		# save the return address
0100010_00001_11101__000000000000001	//addi $at $sp, 1       
0100000_00000_00001_00100_0000000000	//sw $a0, M[$at]       
 
// OPERATION 2: RECURSIVE CALLS
 
0100010_00100_00100__111111111111111	//addi $a0, $a0, -1		# calculate n - 1
0110000_11111_00000__111111111110101	//jal $ra, -11			# calculate fib(n - 1)
 
0100010_00001_11101__000000000000010	//addi $at, $sp, 2      
0100000_00000_00001_00010_0000000000	//sw $v0, M[$at]		# save into the stack result of fib(n - 1)
0100010_00001_11101__000000000000001	//addi $at, $sp, 1      
0010000_00100_00001__000000000000000	//lw $a0, M[$at]		# load the value of n
 
0100010_00100_00100__111111111111110	//addi $a0, $a0, -2		# calculate n - 2
0110000_11111_00000__111111111101111	//jal $ra, -17          
 
0100010_00001_11101__000000000000011	//addi $at, $sp, 3     
0100000_00000_00001_00010_0000000000	//sw $v0, M[$at]		1a# save into the stack the result of fib(n - 2)
 
// OPERATION 3: POP FROM STACK
 
0010000_11111_11101__000000000000000	//lw $ra, M[$sp]		# load the return address
0100010_00001_11101__000000000000010	//addi $at, $sp, 2      
0010000_01000_00001__000000000000000	//lw $t0, M[$at]		# load the value of fib(n - 1)
0100010_00001_11101__000000000000011	//addi $at, $sp, 3      
0010000_01001_00001__000000000000000	//lw $t1, M[$at]		# load the value of fib(n - 2)
0100010_11101_11101__000000000000100	//addi $sp, $sp, 4 		# pop from stack
 
// OPERATION 4: OPEARATION
 
0000010_00010_01000_01001_0000000000	//add $v0, $t0, $t1		# fib(n - 1) + fib(n - 2)
1110000_00000_11111__000000000000000	//jr $ra               

@400
00000000_00000000_00000000_00001100     // 12

